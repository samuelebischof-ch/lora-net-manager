import { Component, OnInit, OnDestroy, OnChanges, Input } from '@angular/core';
import { ApiService } from '../../@services/api.service/api.service';
import { WsService } from '../../@services/ws.service/ws.service';
import { Subscription } from 'rxjs/Subscription';
import { forEach } from '@angular/router/src/utils/collection';
// import { dataApiArray } from './test.data';

@Component({
  selector: 'app-data',
  templateUrl: './data.component.html',
  styleUrls: ['./data.component.scss'],
})
export class DataComponent implements OnInit, OnChanges {
  
  private devicesByRoom;
  private apiDataArray: Array<ApiDataInterface> = [];
  // Input of child element graph
  private dataArray = [];
  private lineChartLabels: Array<string> = [];
  private lineChartLabel = '';
  
  barColor = 'primary';
  barValue = 0;
  barMode = 'determinate';
  
  private direction = 'horizontal';
  
  // private connect = true;
  // private min = Date.now();
  // private max = Date.now();
  // private range = [this.min, this.max];
  
  constructor(private _api: ApiService) { }
  
  onChange(evt) {
    // console.log(evt);
  }
  
  async reloadData(evt) {
    this.barMode = 'indeterminate';
    this.apiDataArray = [];
    this.dataArray = [];
    this.lineChartLabels = [];
    this.initializeAll();
    for (const k in this.devicesByRoom) {
      if (this.devicesByRoom.hasOwnProperty(k)) {
        for (const l in this.devicesByRoom[k].devices) {
          if (this.devicesByRoom[k].devices.hasOwnProperty(l)) {
            if (this.devicesByRoom[k].devices[l].checked) {
              const response = await this._api.getData(this.devicesByRoom[k].devices[l].deveui);
              if (response !== null && response !== undefined) {
                this.apiDataArray.push(response);
              }
            }
          }
        }
      }
    }
    console.log(this.apiDataArray);
    
    this.initializeData();
    this.barMode = 'determinate';
  }
  
  async ngOnInit() {
    await this.getDevicesByRoom();
  }
  
  ngOnChanges() {
  }
  
  getDevicesByRoom() {
    this._api.getDevicesByRoom().subscribe(res => {
      this.devicesByRoom = res;
      // console.log(res);
    });
  }
  
  initializeAll() {
    for (let i = 0; i < 3; i++) { // TODO check
      this.dataArray.push({
        label: '',
        lineChartData: [
        ]
      });
    }
  }
  
  normalizeData(dataApiArray: Array<ApiDataInterface>) { // TODO: check for null data

    const timeline: Array<string> = [];
    const temp: Array<Temp> = [];

    // (1) iterate over all different datasets and extract data
    let counter = 0;
    dataApiArray.forEach(apiDataEl => {
      console.log('outer loop')

      // iterate in every dataset and push data to temp
      let dPointer = 0;
      let tPointer = 0;
      while (dPointer < apiDataEl.date.length && tPointer <= temp.length) {
        // tslint:disable-next-line:max-line-length
        if (tPointer < temp.length && new Date(apiDataEl.date[dPointer]) > new Date(temp[tPointer].date)) { // se piu grande muovi a destra su temp
          // console.log('bigger')
          tPointer++;
        } else if (tPointer < temp.length && new Date(apiDataEl.date[dPointer]).setMilliseconds(0) === new Date(temp[tPointer].date).setMilliseconds(0)) { // se uguale inserisci
          const t: Temp = { date: '', data: [] };
          t.date = apiDataEl.date[dPointer];
          // create data portion for most inside array
          const dataT = [];
          apiDataEl.data.forEach(apiDataElDataEl => {
            dataT.push(apiDataElDataEl.data[dPointer]);
          });
          temp[tPointer].data[counter] = dataT;
          tPointer++;
          dPointer++;
          // console.log('ssssss')
        } else { // se piu piccolo oppure alla fine inizio
          // console.log('ccccc')
          const t: Temp = { date: '', data: [] };
          t.date = apiDataEl.date[dPointer];
          // create data portion for most inside array
          const dataT = [];
          apiDataEl.data.forEach(el => {
            dataT.push(el.data[dPointer]);
          });
          const nulls = [];
          apiDataEl.data.forEach(el => {
            nulls.push(null);
          });
          // create data outside and insert previously created dataT
          for (let i = 0; i < dataApiArray.length; i++) {
            t.data.push(nulls);
          }
          t.data[counter] = dataT;
          // insert t at position tPointer
          temp.splice(tPointer, 0, t);
          tPointer++;
          dPointer++;
        }

      }

      counter++;
    });

    // (2) merge
    console.log(temp);

    // (2) write data back to dataApiArray
    for (let i = 0; i < dataApiArray.length; i++) { // loop on different datasets
      for (let j = 0; j < dataApiArray[i].data.length; j++) { // loop on different sensors
        dataApiArray[i].data[j].data = new Array<number>();
        temp.forEach(tempEl => {
          dataApiArray[i].data[j].data.push(tempEl.data[i][j]);
        });
      }
    }

    console.log(dataApiArray);

    // (3) extract data to timeline
    temp.forEach(element => {
      timeline.push(element.date);
    });

    return timeline;
  }

  initializeData() {
    console.log(this.apiDataArray);
    this.lineChartLabels = this.normalizeData(this.apiDataArray);

    for (let c = 0; c < this.apiDataArray.length; c++) {
      // this.organizeLabels(c);
      for (let i = 0; i < 3; i++) {
        console.log(this.apiDataArray[c].data[i].unit);
        this.dataArray[i].label = this.apiDataArray[c].data[i].label;
        this.dataArray[i].unit = this.apiDataArray[c].data[i].unit; // TODO check loop to much overhead
        this.dataArray[i].lineChartData.push({
          data: this.apiDataArray[c].data[i].data,
          label: this.apiDataArray[c].data[i].deveui,
          spanGaps: true,
        });
      }
    }
  }

}

interface Temp {
  date: string;
  data: Array<Array<number>>;
}

interface ApiDataInterface {
  date: Array<string>;
  data: [ApiDataElInterface];
}

interface ApiDataElInterface {
  label: string;
  unit: string;
  data: Array<number>;
  deveui: string;
}
